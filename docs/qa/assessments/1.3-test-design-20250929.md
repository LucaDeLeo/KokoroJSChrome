# Test Design: Story 1.3 - Create OffscreenAudio Plugin

**Date:** 2025-09-29
**Designer:** Quinn (Test Architect)
**Story:** 1.3 - Create OffscreenAudio Plugin

## Test Strategy Overview

- **Total test scenarios:** 24
- **Unit tests:** 11 (46%)
- **Integration tests:** 11 (46%)
- **E2E tests:** 2 (8%)
- **Priority distribution:** P0: 13, P1: 9, P2: 2

**Testing Philosophy:**
- Shift left with comprehensive unit coverage for plugin logic
- Integration tests validate Chrome API interactions and cross-component flows
- Minimal E2E tests for critical user-facing audio playback paths
- Risk-based prioritization focusing on audio playback correctness and Chrome API constraint handling

---

## Test Scenarios by Acceptance Criteria

### AC1: Create OffscreenAudio plugin with offscreen document management

| ID           | Level       | Priority | Test Scenario                                    | Justification                                                        |
| ------------ | ----------- | -------- | ------------------------------------------------ | -------------------------------------------------------------------- |
| 1.3-UNIT-001 | Unit        | P0       | Plugin initialization with valid eventBus and PAL | Pure initialization logic, validates required dependencies           |
| 1.3-UNIT-002 | Unit        | P0       | Plugin initialization fails with missing eventBus | Error handling for invalid init params                               |
| 1.3-UNIT-003 | Unit        | P0       | Plugin cleanup releases all resources            | Resource cleanup logic validation                                    |
| 1.3-INT-001  | Integration | P0       | Plugin registers with event bus for TTSEvent     | Multi-component: plugin + event bus integration                      |
| 1.3-INT-002  | Integration | P0       | Offscreen document created with correct params   | Chrome Offscreen API contract validation                             |
| 1.3-INT-003  | Integration | P0       | Offscreen document closes on plugin cleanup      | Lifecycle management across Chrome API boundary                      |
| 1.3-INT-004  | Integration | P1       | Document creation failure triggers error event   | Chrome API error handling and event propagation                      |
| 1.3-E2E-001  | E2E         | P0       | Extension loads and initializes OffscreenAudio   | Critical path: plugin available for audio playback on extension load |

---

### AC2: Wrap existing AudioPlayer.js functionality in plugin interface

| ID           | Level       | Priority | Test Scenario                               | Justification                                                  |
| ------------ | ----------- | -------- | ------------------------------------------- | -------------------------------------------------------------- |
| 1.3-UNIT-004 | Unit        | P0       | play() method accepts AudioBuffer and options | Pure method signature and parameter validation                 |
| 1.3-UNIT-005 | Unit        | P0       | pause() method stops playback without cleanup | Playback state management logic                                |
| 1.3-UNIT-006 | Unit        | P0       | resume() method continues paused playback   | State transition logic validation                              |
| 1.3-UNIT-007 | Unit        | P0       | stop() method ends playback and cleans up   | Complete cleanup logic                                         |
| 1.3-UNIT-008 | Unit        | P1       | getPlaybackState() returns current state    | State query logic                                              |
| 1.3-INT-005  | Integration | P0       | Audio plays through offscreen document      | Core audio flow: plugin → offscreen doc → Web Audio API        |
| 1.3-INT-006  | Integration | P1       | Playback progress events emitted via event bus | Event emission across component boundaries                     |
| 1.3-INT-007  | Integration | P1       | setVolume() changes audio output volume     | Audio control integration with Web Audio API                   |
| 1.3-E2E-002  | E2E         | P0       | User TTS request produces audible audio     | Critical user journey: text input → audio output               |

---

### AC3: Implement "stop previous audio" behavior (no complex queuing)

| ID           | Level       | Priority | Test Scenario                                  | Justification                                                       |
| ------------ | ----------- | -------- | ---------------------------------------------- | ------------------------------------------------------------------- |
| 1.3-UNIT-009 | Unit        | P0       | New play() call stops any active playback      | Core stop-previous logic without external dependencies              |
| 1.3-INT-008  | Integration | P0       | Sequential play() calls stop previous audio    | Multi-component: audio manager + offscreen doc state coordination   |
| 1.3-INT-009  | Integration | P0       | Rapid play() calls handle race conditions      | Concurrent audio request handling across async boundaries           |
| 1.3-INT-010  | Integration | P1       | Stop event emitted when previous audio stopped | Event bus integration for stop notifications                        |

---

### AC4: Handle singleton Offscreen document limitation gracefully

| ID           | Level       | Priority | Test Scenario                                       | Justification                                              |
| ------------ | ----------- | -------- | --------------------------------------------------- | ---------------------------------------------------------- |
| 1.3-UNIT-010 | Unit        | P1       | Document existence check returns correct boolean    | Pure existence check logic                                 |
| 1.3-INT-011  | Integration | P1       | Second createDocument() call skips if doc exists    | Chrome API singleton constraint handling                   |
| 1.3-INT-012  | Integration | P1       | Document reused across multiple play() calls        | Document lifecycle across multiple audio sessions          |
| 1.3-INT-013  | Integration | P2       | Multiple plugin instances share single document     | Plugin isolation with shared Chrome API resource           |

---

### AC5: Monitor memory usage and recycle after 20 sessions or 500MB

| ID           | Level       | Priority | Test Scenario                                    | Justification                                                   |
| ------------ | ----------- | -------- | ------------------------------------------------ | --------------------------------------------------------------- |
| 1.3-UNIT-011 | Unit        | P1       | Session counter increments on each play() call   | Pure counter logic                                              |
| 1.3-UNIT-012 | Unit        | P1       | Memory threshold check detects >500MB usage      | Pure threshold comparison logic                                 |
| 1.3-INT-014  | Integration | P1       | Recycle triggered after 20 sessions              | Threshold-based lifecycle management                            |
| 1.3-INT-015  | Integration | P1       | Recycle triggered when memory exceeds 500MB      | Memory monitoring + Chrome API interaction                      |
| 1.3-INT-016  | Integration | P1       | Recycle closes document and resets counters      | Multi-step recycling workflow validation                        |
| 1.3-INT-017  | Integration | P2       | Next play() after recycle creates new document   | Document recreation after recycling                             |

---

## Integration Verification Coverage

| IV   | Description                                | Test IDs Covering                          | Priority |
| ---- | ------------------------------------------ | ------------------------------------------ | -------- |
| IV1  | Audio plays through offscreen document     | 1.3-INT-005, 1.3-E2E-002                   | P0       |
| IV2  | Previous audio stops when new arrives      | 1.3-INT-008, 1.3-INT-009                   | P0       |
| IV3  | Memory stays under 500MB threshold         | 1.3-INT-015, 1.3-INT-016                   | P1       |
| IV4  | Performance metrics track audio latency    | (Covered by pipeline automatic tracking)   | P1       |

---

## Risk Coverage Analysis

**HIGH RISK: Chrome Offscreen API singleton constraint**
Coverage: 1.3-INT-011, 1.3-INT-012, 1.3-INT-013
Mitigation: Integration tests validate existence checks before document creation

**HIGH RISK: Audio playback failures in offscreen context**
Coverage: 1.3-INT-005, 1.3-INT-004, 1.3-E2E-002
Mitigation: Integration + E2E tests validate full audio pipeline

**MEDIUM RISK: Memory leaks from audio buffer retention**
Coverage: 1.3-INT-014, 1.3-INT-015, 1.3-INT-016
Mitigation: Integration tests validate recycling mechanism

**MEDIUM RISK: Race conditions in rapid audio requests**
Coverage: 1.3-INT-009
Mitigation: Stress test for concurrent play() calls

**LOW RISK: Plugin initialization failures**
Coverage: 1.3-UNIT-002, 1.3-INT-004
Mitigation: Unit + integration error handling tests

---

## Test Execution Order (Recommended)

### Phase 1: Critical Path Validation (P0 Unit)
1. 1.3-UNIT-001 (Plugin init success)
2. 1.3-UNIT-002 (Plugin init failure)
3. 1.3-UNIT-003 (Plugin cleanup)
4. 1.3-UNIT-004 to 007 (Audio control methods)
5. 1.3-UNIT-009 (Stop previous audio logic)

**Goal:** Validate core plugin logic before integration testing

### Phase 2: Integration Validation (P0 Integration)
1. 1.3-INT-001 (Event bus registration)
2. 1.3-INT-002 (Offscreen document creation)
3. 1.3-INT-003 (Document cleanup)
4. 1.3-INT-005 (Audio playback through offscreen doc)
5. 1.3-INT-008 (Stop previous audio integration)
6. 1.3-INT-009 (Race condition handling)

**Goal:** Validate Chrome API interactions and cross-component flows

### Phase 3: End-to-End Validation (P0 E2E)
1. 1.3-E2E-001 (Extension load)
2. 1.3-E2E-002 (User TTS → audio output)

**Goal:** Validate complete user journey

### Phase 4: Secondary Features (P1)
- All P1 unit tests (session counter, memory threshold, playback state)
- All P1 integration tests (event emission, singleton handling, recycling)

### Phase 5: Edge Cases (P2)
- 1.3-INT-013 (Multiple plugin instances)
- 1.3-INT-017 (Document recreation post-recycle)

---

## Coverage Gaps & Assumptions

**No Coverage Gaps:** All ACs and IVs have corresponding test scenarios.

**Assumptions:**
1. Web Audio API mocked for unit/integration tests (not testing browser audio stack)
2. Chrome Offscreen API mocked for unit/integration tests (using jest.mock)
3. E2E tests require Chrome extension test harness from Story 1.1
4. Performance metrics (IV4) automatically tracked by pipeline (no explicit test needed)
5. AudioPlayer.js from web app assumed to be working (not retested, only wrapped)

---

## Test Maintenance Considerations

**High Maintainability:**
- Unit tests have no external dependencies (fast, stable)
- Chrome API mocks isolated in test setup (easy to update if API changes)

**Medium Maintainability:**
- Integration tests depend on PAL and event bus (stable interfaces from Story 1.1)
- Offscreen document mocking may need updates if Chrome API evolves

**Low Maintainability:**
- E2E tests may be brittle if extension UI changes (but minimal E2E coverage reduces risk)

---

## Test Data Requirements

**Audio Test Fixtures:**
- Small AudioBuffer (1s, 16kHz mono) - happy path
- Large AudioBuffer (60s, 48kHz stereo) - memory stress test
- Empty AudioBuffer - edge case
- Invalid audio data - error handling

**Memory Simulation:**
- Mock performance.memory with configurable values
- Session counter scenarios: 1, 19, 20, 21 sessions
- Memory scenarios: 400MB, 499MB, 500MB, 501MB

**Offscreen Document States:**
- Document exists (singleton test)
- Document does not exist (creation test)
- Document creation failure (error test)

---

## Test Tooling

**Framework:** Jest (from Story 1.1 testing strategy)

**Mocking Strategy:**
- `jest.mock('chrome.offscreen')` for Chrome Offscreen API
- `jest.mock('AudioContext')` for Web Audio API
- `jest.mock('performance.memory')` for memory monitoring
- Event bus and PAL mock harnesses from Story 1.1

**Test Execution:**
```bash
# All tests
npm test plugins/offscreen-audio

# Unit tests only
npm test plugins/offscreen-audio/test/offscreen-audio.test.js

# Integration tests only
npm test plugins/offscreen-audio/test/integration
```

---

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 24
  by_level:
    unit: 11
    integration: 11
    e2e: 2
  by_priority:
    p0: 13
    p1: 9
    p2: 2
    p3: 0
  coverage_gaps: []
  risk_coverage:
    - risk: "Chrome Offscreen API singleton constraint"
      tests: ["1.3-INT-011", "1.3-INT-012", "1.3-INT-013"]
    - risk: "Audio playback failures"
      tests: ["1.3-INT-005", "1.3-INT-004", "1.3-E2E-002"]
    - risk: "Memory leaks"
      tests: ["1.3-INT-014", "1.3-INT-015", "1.3-INT-016"]
  iv_coverage:
    iv1: ["1.3-INT-005", "1.3-E2E-002"]
    iv2: ["1.3-INT-008", "1.3-INT-009"]
    iv3: ["1.3-INT-015", "1.3-INT-016"]
    iv4: ["pipeline-automatic"]
```

---

## Quality Checklist

- [x] Every AC has test coverage (5 ACs, all covered)
- [x] Test levels are appropriate (46% unit for logic, 46% integration for Chrome API, 8% E2E for user journeys)
- [x] No duplicate coverage across levels (each test validates different aspects)
- [x] Priorities align with business risk (P0 = core audio playback, P1 = stability features)
- [x] Test IDs follow naming convention (1.3-{LEVEL}-{SEQ})
- [x] Scenarios are atomic and independent (no test dependencies)
- [x] All Integration Verifications covered
- [x] Risk-based coverage addressed

---

## Test Design Summary

**Strengths:**
- Comprehensive unit test coverage for plugin logic (11 tests, 46%)
- Strong integration coverage for Chrome API interactions (11 tests, 46%)
- Minimal but focused E2E tests for critical user paths (2 tests, 8%)
- All P0 scenarios cover revenue-critical audio playback functionality
- Risk-based prioritization addresses Chrome API constraints and memory management

**Efficient Coverage Strategy:**
- Unit tests validate logic first (fail fast)
- Integration tests validate Chrome API contracts
- E2E tests only for user-facing audio playback (avoid over-testing)
- No duplicate coverage across levels

**Recommended Execution:** Run P0 tests first (19 tests) to validate critical audio playback before proceeding to P1 stability features.